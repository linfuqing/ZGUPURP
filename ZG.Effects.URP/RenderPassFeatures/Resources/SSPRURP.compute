#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"


RWTexture2D<half4> RflectRT;//存储反射后的颜色

RWTexture2D<half> ReDepthBufferRT;//我们只用r通道 所以一维足以

Texture2D<float4> _ScreenColorTex;//接收屏幕颜色图

Texture2D<float4> _ScreenDepthTex;//接收屏幕深度图

float2 RTSize;

float ReflectPlaneHeight;

float FadeOut2Edge;

SamplerState PointClampSampler;//像素采样，clamp类型

SamplerState LinearClampSampler;//模糊采样，clamp类型

half sdfCube(half2 pos)
{
    half2 dis = abs(pos) - half2(1, 1);

    return length(max(dis, 0.0)) - min(max(dis.x, dis.y), 0.0);

}

#pragma kernel CSMain

[numthreads(8, 8, 1)]//最好是64的整数来提高性能，小于等于256保证移动端的性能支持

void CSMain(uint3 id:SV_DispatchThreadID)
{
    RflectRT[id.xy] = half4(0, 0, 0, 0);//我自定义反射后的颜色缓冲区 给了个初始颜色纯黑色 如果后续的各种测试通过 则把计算出来的颜色写入该缓冲区

    ReDepthBufferRT[id.xy] = 0;//我自定义的反射后的深度缓冲区 给了个初始深度 如果后续的各种测试通过 则把计算出来的深度写入该缓冲区

    float2 SSUV = id.xy / RTSize;//由线程id换算到屏幕uv  0-RTSize-1 remap 到01  

    float NDCposZ = _ScreenDepthTex.SampleLevel(PointClampSampler, SSUV, 0).x;//得到深度根据uv采样对应的id，这里使用point模式+clamp

    float4 NDCpos = float4(SSUV * 2.0 - 1.0, NDCposZ, 1);//这里没有考虑反向Z 因为VP的逆矩阵已经处理好了反Z

    float4 HWSpos = mul(UNITY_MATRIX_I_VP, NDCpos);//得到经过透除的世界坐标 其w值是我们用于透除的w（near，far）的倒数

    float3 WSpos = HWSpos.xyz / HWSpos.w;//得到正常的世界坐标

    //RflectRT[id.xy]=float4(WSpos,1);

    if (WSpos.y < ReflectPlaneHeight)
        return;//测试1：高度测试，低于反射平面高度的测试失败 不写入颜色和深度

    float3 reWSpos = WSpos;

    reWSpos.y = -(reWSpos.y - ReflectPlaneHeight) + ReflectPlaneHeight;

    float4 reCSpos = mul(UNITY_MATRIX_VP, float4(reWSpos, 1));

    float2 reNDC = reCSpos.xy / reCSpos.w;

    if (abs(reNDC.x) > 1 || abs(reNDC.y) > 1) 
        return;//测试2 NDC测试，超出NDC的部分测试失败 不写入颜色和深度

    float2 reSSUV = reNDC * 0.5 + 0.5;

#ifdef UNITY_UV_STARTS_AT_TOP //DX平台有Y翻转要考虑

    reSSUV.y = 1 - reSSUV.y;

#endif

    uint2 reSSUVid = reSSUV * RTSize;

#ifdef UNITY_REVERSED_Z

    if (reCSpos.z < ReDepthBufferRT[reSSUVid])
        return;//DX平台的深度测试 有Z反转  深度小的像素测试失败 不写入颜色和深度

#else

    (reCSpos.z >= ReDepthBufferRT[reSSUVid])
        return;//OpenGL平台的深度测试 没有Z反转  深度大的像素测试失败 不写入颜色和深度

#endif

    half mask = sdfCube(SSUV * 2 - 1);//屏幕中心到屏幕边缘的距离,有向

    mask = smoothstep(0, FadeOut2Edge, abs(mask));

    //RflectRT[reSSUVid]=mask;

    RflectRT[reSSUVid] = half4(_ScreenColorTex.SampleLevel(LinearClampSampler, SSUV, 0).xyz, mask);//写入颜色到反射颜色缓冲区

    ReDepthBufferRT[reSSUVid] = reCSpos.z;//写入深度到反射深度缓冲区

}